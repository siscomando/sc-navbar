<link rel="import" href="../font-roboto/roboto.html">
<link rel="import" href="../core-icon/core-icon.html">
<link rel="import" href="../core-icons/image-icons.html">
<link rel="import" href="../core-icons/communication-icons.html">
<link rel="import" href="../core-menu/core-menu.html">
<link rel="import" href="../paper-elements/paper-elements.html">
<link rel="import" href="../core-menu/core-submenu.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../sc-item/sc-item.html">
<link rel="import" href="../sc-sse/sc-sse.html">

<!--
sc-navbar is an custom element that retrieves and shows the issues. That
is required core-ajax.

##### Example

    <sc-navbar
      url="issues.json"
      username="chuangina" 
      online="true" 
      avatar="http://api.randomuser.me/portraits/thumb/women/79.jpg">
    </sc-navbar>

@element sc-navbar
@blurb Element providing the navbar to the sisComando app.
@status alpha
@homepage http://github.com/siscomando/sc-navbar
-->
<polymer-element name="sc-navbar" 
  attributes="notitle url urlupdates author username avatar avatarSize gravatarEnabled online method stream channel alias filter">

  <template>
    <link rel="stylesheet" href="sc-navbar.css">
    <!-- get from remote -->
    <sc-sse stream="{{stream}}" channel="{{channel}}" alias="{{alias}}"></sc-sse>
    <core-ajax id="coreAjax"
      auto
      url="{{url}}"
      response="{{response}}"
      handleAs="json"
      method="{{method ? method : 'GET'}}" >
    </core-ajax>

    <!-- presentation issues -->
    <div class="mainContent">

      <!-- start: Search section -->
      <div id="inputFilter">
        <!-- <paper-icon-button id="btnComment" icon="communication:chat"></paper-icon-button> -->
        <paper-input-decorator raised="true" label="Filtrar...">
          <input id="filterText" type="text" is="core-input" name="f" value="" autocorrect="off" on-keyup="{{setFilter}}" />
        </paper-input-decorator> 
      </div>      
      <!-- end: Search section -->

      <!-- menu item: This object fire core-select event -->
      <core-menu id="coreMenu">
          <h5>Em andamento <!--({{totalOpened}})--></h5>
          <template repeat="{{ issue in _groupedIssues}}">
            <div class="counterItems">{{issue.issues.length}}</div>
            <core-submenu>
                  <div class="item-content">
                    {{issue.name}}
                  </div>
                  <template repeat="{{ item in issue.issues }}">
                    <sc-item scid="{{ item }}">
                  	 {{ item }}</sc-item>
                  </template>
            </core-submenu>            
          </template>
      </core-menu>

    <!-- profile section -->
    <div class="profileMenu" horizontal layout>
      <div id="avatar">
      </div>
      <div class="username" flex>{{username}}
        <span class="status">
          <core-icon icon="radio-button-on" 
            style="{{ online ? 'color: #B8E986;' : 'color: #CCC;' }}">
          </core-icon>{{online ? 'online' : 'offline' }}</span>
      </div>
      <paper-menu-button>
          <paper-icon-button icon="menu" noink></paper-icon-button>
          <paper-dropdown class="dropdown">
              <core-menu class="menu">
                  <!-- INFO: change the paper-dropdown's css max-heigth to add new itens -->
                  <paper-item>Share</paper-item>
                  <paper-item><a href="/settings">Settings</a></paper-item>
                  <paper-item><a href="/logout">Logout</a></paper-item>
              </core-menu>
          </paper-dropdown>
      </paper-menu-button>      
    </div>
    <!-- profile section -->

    </div>
    

  </template>

  <script> 
    function search(string, myList){
        var newArray = [];
        for (var i=0; i < myList.length; i++) {
            if (myList[i].register.indexOf(string) > -1) {
                newArray.push(myList[i]);
            }
        }
        return newArray;
      }

    Polymer({ 
       /**
       * Fired when a item is selected.
       *
       *
       * @event sc-select
       */    
      /**
       * The `method` attribute sets an HTTP method to get issues.
       *
       * @attribute method
       * @type string
       * @default 'GET'
       */       
      /**
       * The `author` attribute sets an initial author
       *
       * @attribute author
       * @type string
       * @default 'Horacio Ibrahim'
       */
      author: 'Horacio Ibrahim', 
      /**
       * The `icons` attribute sets an type for the issue as high, 
       * high-infra, high-x.
       *
       *      Usage:
       *
       *          icons[0|1|2]
       * 
       * @attribute icons
       * @type string
       * @default 'error'
       */      
      publish: {
          displaySearch: {value: false, reflect: true},  
          select: 0, 
          _groupedIssues: [],
          avatar: null,
          avatarSize: "42px",
          gravatarEnabled: true,
      },
      /* the best place to the constructor for array or object */
      created: function() {
        // initialize but it not is turned public to use by users of the element
        // to turn public to use attributes or publish.
      },
      ready: function() {
        this.showAvatar();
        this.addEventListener('core-select', function(event){
          /*
          TODO: Not open when to exist only one issue
          items = event.detail.item.items
          countItens = items ? items.length : 0
          if (countItens === 1) {
          };
          */
          if (event.detail.isSelected) {
            this.scid = event.detail.item.scid;
            // toggle drawer
            var coreDrawer = document.querySelector('core-drawer-panel');
            // access storage
            var localIssues = JSON.parse(window.localStorage.getItem("dbIssues"));
            for (var i=0; i< localIssues.length; i++) { 
              // field to store id (_id, primary key) is register
              if (localIssues[i]['register'] === this.scid) { 
                this.fire('sc-select', {issue: localIssues[i]['register']});
                coreDrawer.togglePanel();
              } 
            }
          }
        });

        // handling updates from sse
        this.addEventListener('sc-sse-response', function(e){
          doc =  e.detail.response;
          if (!(doc == 1)) {
            doc = JSON.parse(e.detail.response);
            db = window.localStorage.getItem("dbIssues");
            db = JSON.parse(db);
            
            // if doc is closed to remove from view (navbar)
            if (doc.closed == true) {
              for (item in db) {
                if (db[item].register == doc.register) {
                    db.splice(item, 1);
                }
                if (this.scid == doc.register) {
                    location.href = '/'; // to prevent sc-header with old issue selected. Go back home.
                }                
              }
            } else {
              db.push(doc);  
              // when doc is added in db to change issuesOrig. It was initiated 
              // in first request.
              this.issuesOrig = db;
            }
            
            window.localStorage.setItem("dbIssues",JSON.stringify(db));
            this.updateIssues();
          }
        });
      },   
      cleanerClosed: function(elem, index, arr) {
          // cleaner: to remove issue from db if exists closed issue in localStorage
          if (elem.closed == true){
            arr.splice(index, 1);
        }
      },  
      responseChanged: function() {
      	  this.issuesOrig = this.issues = this.response['issues'];
      	  window.localStorage.setItem("dbIssues",JSON.stringify(this.issues));
          this.updateIssues();
          
      },
      updateIssues: function() {
          db = JSON.parse(window.localStorage.getItem("dbIssues"));
          db.forEach(this.cleanerClosed);
          window.localStorage.setItem("dbIssues", JSON.stringify(db));
          this.sortByScope();
      },
      menuReferrer: function(name) {
        // t.split(' ').join('')
        if (!(name === undefined)) {
          return name.split(' ').join('');
        }
      }, 
      hasOne: function(slist) {
        myList = slist; 
        if (myList.length === 1) {
          return [true, myList[0]];
        } else {
          return [false];
        }
      },
      showAvatar: function() {
        if (this.avatar) {

          if (this.gravatarEnabled) {
            // this.avatar is the md5 of the email
            gravatarUrl = '//www.gravatar.com/avatar/' + this.avatar + "?s=" + this.avatarSize;
            this.$.avatar.innerHTML = '<img src="' + gravatarUrl+ '">';
          } else {
            // this.avatar must be a link to image in media files
            this.$.avatar.innerHTML = '<img src="' + this.avatar + '">';
          }
    
        } else {
          this.$.avatar.innerHTML = '<core-icon icon="account-box"></core-icon>';
        }
      },
      /**
       * The `sortByScope` sort and grouping attachField by field.
       *
       * 
       * @method sortByScope
       * @param field [string]
       * @default 'title'
       */      
      sortByScope: function(field, attachField) {
          // initializing variables default
          // TODO: fix this implementation in backend
          field = field ? field : "title";
          attachField = attachField ? attachField : "register";
          var localIssues = JSON.parse(window.localStorage.getItem("dbIssues"));
          var scopeList = [];
          for (item in localIssues) {
               var obj = {};
               var newField = localIssues[item][field]; // is value of the title
               obj[newField] = {};
               obj[newField]['name'] = newField; // monkey patch
               obj[newField]['issues'] = []; // arrary that receives issues            
               
               if (scopeList.length === 0) {
                  scopeList.push(obj)
               } 
               
               var found = false;
               for (nf in scopeList) {
                   if (newField in scopeList[nf]) {
                      scopeList[nf][newField]['name'] = newField; // monkey patch
                      scopeList[nf][newField]['issues']
                                          .push(localIssues[item][attachField]);
                      found = true;
                   } 
               }

               if (found === false) { 
                 obj[newField]['issues'].push(localIssues[item][attachField]);            
                 scopeList.push(obj); 
               }                
          }
        this._groupedIssues = [];
        for (elem in scopeList) { 
          this._groupedIssues.push(scopeList[elem][Object.keys(scopeList[elem])[0]]); 
        }
        // return scopeList; // to comment this in production enviroment 
    },
      filterChanged: function(){
        var issuesOrig = this.issuesOrig;

        if(this.filter) {
          issuesFiltered = (search(this.filter, issuesOrig).length > 0) ?
          search(this.filter, issuesOrig) : [];
          window.localStorage.setItem("dbIssues", JSON.stringify(issuesFiltered));
          this.updateIssues();
        } else {
          window.localStorage.setItem("dbIssues", JSON.stringify(issuesOrig));
          this.updateIssues();
        }
      },
      /**
       * The `setFilter` filters the issues listed in core-menu
       *
       * @method setFilter
       */  
      setFilter: function() {
        this.filter = this.$.filterText.value;
      },
      showText: function() {
        this.$.inputFilter.hidden = false;
      },
      _groupedIssuesChanged: function() {
        this.totalOpened = this._groupedIssues.length;
      }     
    });
  </script>

</polymer-element>
