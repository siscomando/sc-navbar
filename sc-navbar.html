<link rel="import" href="../font-roboto/roboto.html">
<link rel="import" href="../core-icon/core-icon.html">
<link rel="import" href="../core-icons/image-icons.html">
<link rel="import" href="../core-icons/communication-icons.html">
<link rel="import" href="../core-menu/core-menu.html">
<link rel="import" href="../paper-elements/paper-elements.html">
<link rel="import" href="../core-menu/core-submenu.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../sc-item/sc-item.html">
<link rel="import" href="../sc-sse/sc-sse.html">

<!--
sc-navbar is an custom element that retrieves and shows the issues. That
is required core-ajax.

##### Example

    <sc-navbar
      url="issues.json"
      username="chuangina" 
      online="true" 
      avatar="http://api.randomuser.me/portraits/thumb/women/79.jpg">
    </sc-navbar>

@element sc-navbar
@blurb Element providing the navbar to the sisComando app.
@status alpha
@homepage http://github.com/siscomando/sc-navbar
-->
<polymer-element name="sc-navbar" 
  attributes="notitle url urlupdates author username avatar online method stream channel alias filter">

  <template>
    <link rel="stylesheet" href="sc-navbar.css">
    <!-- get from remote -->
    <sc-sse stream="{{stream}}" channel="{{channel}}" alias="{{alias}}"></sc-sse>
    <core-ajax id="coreAjax"
      auto
      url="{{url}}"
      response="{{response}}"
      handleAs="json"
      method="{{method ? method : 'GET'}}" >
    </core-ajax>

    <!-- presentation issues -->
    <div class="mainContent">

      <!-- start: Search section -->
      <div id="inputFilter">
        <!-- <paper-icon-button id="btnComment" icon="communication:chat"></paper-icon-button> -->
        <paper-input-decorator raised="true" label="Filtrar...">
          <input id="filterText" type="text" is="core-input" name="f" value="" autocorrect="off" on-keyup="{{setFilter}}" />
        </paper-input-decorator> 
      </div>      
      <!-- end: Search section -->

      <!-- menu item: This object fire core-select event -->
      <core-menu id="coreMenu">
          <template repeat="{{ issue in menuBySystem}}">
            <core-submenu>
                  <div class="item-content">
                    {{issue.name}}
                  </div>
                  <template repeat="{{ item in issue.issues }}">
                    <sc-item scid="{{ item }}">
                  	 {{ item }}</sc-item>
                  </template>
            </core-submenu>            
          </template>
      </core-menu>

    <!-- profile section -->
    <div class="profileMenu" horizontal layout>
      <div id="avatar">
      </div>
      <div class="username" flex>{{username}}
        <span class="status">
          <core-icon icon="radio-button-on" 
            style="{{ online ? 'color: #B8E986;' : 'color: #CCC;' }}">
          </core-icon>{{online ? 'online' : 'offline' }}</span>
      </div>
    </div>
    <!-- profile section -->

    </div>
    

  </template>

  <script> 
    function search(string, myList){
        var newArray = [];
        for (var i=0; i < myList.length; i++) {
            if (myList[i].register.indexOf(string) > -1) {
                newArray.push(myList[i]);
            }
        }
        return newArray;
      }

    Polymer({ 
       /**
       * Fired when a item is selected.
       *
       *
       * @event sc-select
       */     
      /**
       * The `method` attribute sets an HTTP method to get issues.
       *
       * @attribute method
       * @type string
       * @default 'GET'
       */       
      /**
       * The `author` attribute sets an initial author
       *
       * @attribute author
       * @type string
       * @default 'Horacio Ibrahim'
       */
      author: 'Horacio Ibrahim', 
      /**
       * The `icons` attribute sets an type for the issue as high, 
       * high-infra, high-x.
       *
       *      Usage:
       *
       *          icons[0|1|2]
       * 
       * @attribute icons
       * @type string
       * @default 'error'
       */      
      publish: {
          displaySearch: {value: false, reflect: true},  
          select: 0, 
          menuBySystem: [],
          avatar: null
      },
      /* the best place to the constructor for array or object */
      created: function() {
        // initialize but it not is turned public to use by users of the element
        // to turn public to use attributes or publish.
      },
      ready: function() {
        this.showAvatar();
        this.addEventListener('core-select', function(event){
          /*
          TODO: Not open when to exist only one issue
          items = event.detail.item.items
          countItens = items ? items.length : 0
          if (countItens === 1) {
          };
          */
          if (event.detail.isSelected) {
            var scid = event.detail.item.scid;
            // toggle drawer
            var coreDrawer = document.querySelector('core-drawer-panel');
            // access storage
            var issuesSaved = JSON.parse(window.localStorage.getItem("dbIssues"));
            for (var i=0; i< issuesSaved.length; i++) { 
              // field to store id (_id, primary key) is register
              if (issuesSaved[i]['register'] === scid) { 
                this.fire('sc-select', {issue: issuesSaved[i]['register']});
                coreDrawer.togglePanel();
              } 
            }
          }
        });
        this.addEventListener('sc-sse-response', function(e){
          // handling updates
          doc =  e.detail.response;
          if (!(doc == 1)) {
            doc = JSON.parse(e.detail.response);
            db = window.localStorage.getItem("dbIssues");
            db = JSON.parse(db);;
            db.push(doc);
            window.localStorage.setItem("dbIssues",JSON.stringify(db));
            // badge
            // TODO: title = this.menuReferrer(doc.title);
            // update info
            this.updateIssues();
          }
        });
      },      
      responseChanged: function() {
      	  this.issueOrig = this.issues = this.response['issues'];
      	  window.localStorage.setItem("dbIssues",JSON.stringify(this.issues));
          this.updateIssues();
          
      },
      updateIssues: function() {

          this.sortByScope();

      },
      menuReferrer: function(name) {
        // t.split(' ').join('')
        if (!(name === undefined)) {
          return name.split(' ').join('');
        }
      }, 
      hasOne: function(slist) {
        myList = slist; 
        if (myList.length === 1) {
          return [true, myList[0]];
        } else {
          return [false];
        }
      },
      showAvatar: function() {
        if (this.avatar) {
          this.$.avatar.innerHTML = '<img src="' + this.avatar + '">';
        } else {
          this.$.avatar.innerHTML = '<core-icon icon="account-box"></core-icon>';
        }
      },
      /**
       * The `sortByScope` sort and grouping dbIssues by field.
       *
       * 
       * @method sortByScope
       * @param field [string]
       * @default 'title'
       */      
      sortByScope: function(field, attachField) {
          // initializing variables default
          // TODO: fix this implementation
          field = field ? field : "title";
          attachField = attachField ? attachField : "register";
          var issuesSaved = JSON.parse(window.localStorage.getItem("dbIssues"));
          var scopeList = [];
          for (item in issuesSaved) {
               var obj = {};
               var newField = issuesSaved[item][field]; // is value of the title
               obj[newField] = {};
               obj[newField]['name'] = newField; // monkey patch
               obj[newField]['issues'] = [];             
               
               if (scopeList.length === 0) {
                  scopeList.push(obj)
               } 
               
               var found = false;
               for (nf in scopeList) {
                   if (newField in scopeList[nf]) {
                      scopeList[nf][newField]['name'] = newField; // monkey patch
                      scopeList[nf][newField]['issues']
                                          .push(issuesSaved[item][attachField]);
                      found = true;
                   } 
               }

               if (found === false) { 
                 obj[newField]['issues'].push(issuesSaved[item][attachField]);            
                 scopeList.push(obj); 
               }                
          }
        this.menuBySystem = [];
        for (elem in scopeList) { 
          this.menuBySystem.push(scopeList[elem][Object.keys(scopeList[elem])[0]]); 
        }
        // return scopeList; // to comment this in production enviroment 
    },
      filterChanged: function(){
        var issueOrig = this.issueOrig;
        var issueRes = [];
        if(this.filter) {
          issuesFiltered = (search(this.filter, issueOrig).length > 0) ?
          search(this.filter, issueOrig) : [];
          window.localStorage.setItem("dbIssues", JSON.stringify(issuesFiltered));
          this.updateIssues();
        } else {
          window.localStorage.setItem("dbIssues", JSON.stringify(issueOrig));
          this.updateIssues();
        }
      },
      /**
       * The `setFilter` filters the issues listed in core-menu
       *
       * @method setFilter
       */  
      setFilter: function() {
        this.filter = this.$.filterText.value;
      },
      showText: function() {
        this.$.inputFilter.hidden = false;
      }       
    });
  </script>

</polymer-element>
